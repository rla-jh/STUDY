# 운영체제

---

## 1️⃣ 일반적인 운영체제 동작 방식

**1-컴퓨터가 켜지게 되면서 CPU는 가장 먼저 Boot loader를 읽는다.** 

CPU가 곧바돌 읽어들여야 하기 때문에 Boot loader는 처음부터 메인 메모리에 위치해있다. 

Boot loader를 잘못 건드리면 컴퓨터가 실행 되지 않기 때문에 아무나 건드리지 못하게 메로리 안에서도 ROM(Read Only Memory)라는 영역에 할당 되어 있다.

**2-CPU가 boot loader를 읽어드리면 컴퓨터 내부의 각종 초기화 작업을 진행한다.**

(부팅화면 → 컴퓨터가 내부적으로 초기화 작업을 하고 있는 상태)

**3-디스크에 있던 OS 프로그램이 Boot loader에 의해 OS가 메모리에 올라가게 된다.**

**4-메모리에 올라간 OS 프로그램을 CPU가 읽어들이면서 OS를 초기 세팅한다.**

> Boot loader : 컴퓨터를 초기화 시키기 위한 명령어를 모아둔 프로그램, 운영체제를 메모리에 업로드 한다.
> 

## 2️⃣ 프로세스 관리

<aside>
💡 ** 프로세스 **
하드디스크에 있는 프로그램이 메인 메모리로 적재되어 있을때, 즉 실행 중인 프로그램을 말한다.

</aside>

### 💬 프로세스 상태

- new - 메인 메모리에 올라오는 상태
- ready - CPU 할당을 기다리는 상태
- runnig - CPU가 할당되어 작업을 수행중인 상태
- waiting - I/O와 같은 CPU 외의 할당을 받아 기다리는 상태
- terminated - 모든 작업이 끝난 상태

![Untitled](https://t1.daumcdn.net/cfile/tistory/2462574058F328DE29)

→ 이러한 상태를 나타내기 위해서는 프로세스에 대한 모든 정보가 저장되어 있는 곳이 필요하다. 그것을 **PCB(Process Control Block)**이라 부른다.

PCB는 각 프로세스마다 하나씩 존재하며 프로세스 상태, PC값, MMU 정보, CPU time 등 프로세스에 관련된 모든 사항을 기록한다.

### 💬 프로세스 대기열과 스케쥴러 종류

메인 메모리에는 많은 프로세스들이 존재하고, 하드디스크에는 더 많은 프로그램들이 존재한다. 하지만 할당할 수 있는 CPU는 하나이고 메인 메모리의 공간에도 한계가 존재한다. 따라서 프로세스들이 수행하기 위해서는 줄을 서서 기다려야 한다.

- Job Queue - 디스크의 프로그램이 메인메모리에 적재되기 위해 대기하는 줄
    - Job Scheduler에서 관리한다.
    - Job Scheduler는 메모리가 가득 찬 경우 하나의 프로세스가 종료되어 빈자리가 생겨야 동작한다.
- Ready Queue - CPU를 사용하려는 프로세스들이 대기하는 줄
    - CPU Scheduler에서 관리한다.
    - CPU Switch는 1초에도 수십번씩 발생하기 때문에 Scheduler의 활동 주기가 짧아서 붙여진 이름이다.
- Device Queue - 하드디스크나 I/O의 할당을 받기 위해 프로세스들이 대기하는 줄
    - 각 장치별로 대기열이 존재하지만 통칭해서 Device Queue라고 한다.
    - Device Scheduler에서 관리한다.
    

### 💬 다중 프로그래밍(Multiprogramming)

**메모리에 여러개의 프로세스를 적재하는 시스템 (다중 프로세스를 활용)**

프로세스에는 I/O와 같이 Device를 주로 사용하는 프로세스가 있고, CPU를 주로 사용하는 프로세스가 있다. 하지만 메인 메모리로 올라오는 프로세스의 종류가 한 쪽으로 치우친다면 프로세스를 처리하는데 사용되는 시간이 매우 오래 걸리게 된다.

그래서 Job Scheduler에서는 두 종류의 프로세스를 적절히 조화 시켜 메인 메모리에 올린다.

다중 프로그래밍에서 가장 중요한 작업은 메모리에 있는 안쓰는 프로세스는 하드디스크로 보내고 다시 사용하는 프로그램은 적절하게 메모리에 올리는 작업을 진행하는 것이다. 이러한 작동을 **Swapping** 이라고 한다.

그러기 위해서는 적절한 **문맥전환(Context switching)**이 필수적이다. 이런 역할을 하는 장치들은 **Scheduler**와 **Dispatcher**가 있다.

**Scheduler**은 선택을 하는 존재이다. 어떤 프로세스가 적절한지에 대한 선택을 진행한다.그에 대한 실행, 할당은 **Dispatcher**가 진행한다.

## 3️⃣ 쓰레드(Thread)와 병행성

**프로세스 내에서 실행되는 흐름 단위**

- 프로세스 내 주소 공간이나 자원 공유가 가능하다
- 한 개의 프로세스 내에는 반드시 하나 이상의 쓰레드가 존재한다.

### 💬 쓰레드 특징

- 각자 자신의 stack 영역을 보유한다.( 최소한 자신의 레지스터 상태를 보유한다.)
- 프로세스 내의 Code, Data, Heap 영역을 공유하지만 프로세스 간에는 서로 메모리에 접근할 수 없다.
- 한 쓰레드가 프로세스 자원을 변경하면 다른 쓰레드도 그 변경 결과를 가져올 수 있다.

![Untitled](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdqBr2Z%2FbtriX7OJWvq%2FjBmQ6TMvLFWf65yQFLdNz0%2Fimg.png)

### 쓰레드가 필요한 이유

→ 여러 개의 작업 단위로 구성된 프로그램에서 요청을 동시에 처리하기 위함이다.

일반적으로 한 프로그램은 하나의 쓰레드(Thread)를 가지고 있지만, 프로그램 환경에 따라 둘 이상의 스레드(Thread)를 동시에 실행할 수 있는데 이러한 방식을 **멀티쓰레드(multithread)**라고 한다.

### 💬 멀티 프로세스와 멀티 쓰레드 차이

예를 들어, 식당에서 피자를 만들고 햄버거를 만드는 것을 멀티 프로세스라고 할 수 있고 햄버거를 만드는 과정 내에서 양상추를 씻고, 패티를 굽는 것을 멀티 쓰레드라고 할 수 있다.

## 4️⃣ 메모리 관리

> **메모리**
메인 메모리, RAM 이라 한다. 프로그램 실행 시 필요한 주소, 정보들을 저장하고 가져다 사용할 수 있게 만든 공간, 즉 작업을 위해 사용되는 공간이다.
> 

**가장 단순한 형태의 메모리 관리 방법**

프로그램의 요청이 있을 때, 메모리의 일부를 해당 프로그램에 할당하고, 더 이상 필요하지 않을 때 나중에 다시 사용할 수 있도록 할당을 해제하는 것

### 💬 Swapping

메모리 관리를 위해 사용되는 기법, **메모리에 적재되어 있으나 현재 사용되지 않고 있는 프로세스를 관리하는 역할**

round-robin 과 같은 스케줄링의 다중 프로그래밍 환경에서 CPU 할당 시간이 끝난 프로세스의 메모리를 보조기억장치로 내보내고 다른 프로세스의 메모리를 불러 온다.

swap-in : 주 기억 장치(RAM)로 불러오는 과정

swap-out : 보조 기억 장치로 내보내는 과정

### 💬 연속 메모리 할당

**프로세스를 메모리에 연속적으로 할당하는 기법**

- 할당과 제거를 반복하다보면 Scattered holes가 생겨나고 이로 인한 외부 단편화 발생
    - 최초 적합(first fit) - 가장 처음 만나는 빈 메모리 공간에 프로세스 할당
    - 최적 적합(best fit) - 빈 메모리 공간의 크기와 프로세스의 크기 차이가 가장 적은 곳에 프로세스 할당
    - 최악 적합(worst fit) - 빈 메모리 공간의 크기와 프로세스의 크기 차이가 가장 큰 곳에 프로세스 할당
    

### 💬 페이징(Paging) - 가상 메모리 사용, 외부 단편화 해결, 내부 단편화 존재

**하나의 프로세스가 사용하는 메모리 공간이 연속적이어야 한다는 제약을 없애는 메모리 관리 방법**

외부 단편화와 압축 작업을 해소하기 위해 생긴 방법론으로, 물리 메모리는 Frame이라는 고정 크기로 분리되어 있고, 논리 메모리(프로세스가 점유하는)는 페이지라 불리는 고정 크기의 블록으로 분리된다.

논리 메모리는 물리 메모리에 저장될 때, 연속되어 저장될 필요 없고, 물리 메모리의 남은 프레임에 적절히 배치됨으로 외부 단편화를 해결할 수 있다.

### 💬 세그먼테이션(Segmentation) - 가상 메모리 사용, 내부 단편화 해결, 외부 단편화 존재

**페이징에서처럼 논리 메모리와 물리 메모리를 같은 크기의 블록이 아닌, 서로 다른 크기의 논리적 단위인 세그먼트(segment)로 분할**

### 💬 세그먼테이션 페이징 혼용 기법

페이징과 세그먼테이션을 혼용해 단편화를 최대한 줄이는 전략.

**프로세스를 세그먼트(논리적 기능 단위)로 나눈 다음 세그먼트를 다시 페이지 단위로 나누어 관리**

- 매핑 테이블을 두번 거쳐야하므로 속도가 느려짐

### 💬 메모리 풀(Memory pool)

**필요한 메모리 공간을 필요한 크기, 개수 만큼 사용자가 직접 지정하여 미리 할당받아 놓고 필요할 때마다 사용하고 반납하는 기법**

### 💬 가상 메모리 시스템

**프로세스가 사용하는 메모리 주소를 실제 물리 주소와 구분한다.** 

이로써 프로세스를 구분하고 디스크 스왑 처리를 사용하여 효과적으로 램의 양을 늘릴 수 있다.

> **외부 단편화** : 여유 공간이 충분함에도 불구하고 여유 공간들이 조각으로 흩어져 있어 메모리에 프로세스를 적재하지 못해 메모리가 낭비되는 현상

**내부 단편화** : 고정 분할 방식에서 프로세스가 실제 사용해야 할 메모리보다 더 큰 메모리를 할당받아 메모리가 낭비되는 현상
> 

## 5️⃣ 프로세스 간 통신

**프로세스들 사이에 서로 데이터를 주고 받는 행위 또는 그에 대한 방법이나 경로**

### 💬 공유 메모리

**공유 메모리가 데이터 자체를 공유하도록 지원하는 설비, 프로세스 간 메모리 영역을 공유해서 사용할 수 있도록 허용한다.**

프로세스가 공유 메모리 할당을 커널에 요청하면 커널은 해당 프로세스에 메모리 공간을 할당한다. 이후 어떤 프로세스건 해당 메모리 영역에 접근할 수 있다.

→ 중개자 없이 바로 메모리에 접근할 수 있기 때문에 가장 빠르게 동작할 수 있다.

### 💬 파이프(Pipe)

**통신을 위한 메모리 공간(버퍼)를 생성하여 프로세스가 데이터를 주고 받게끔한다.**

- 익명 파이프 - 통신할 프로세스가 명확하게 알 수 있는 경우 사용
- 네임드 파이프 - 전혀 모르는 상태의 프로세스들 사이의 통신에 사용

### 💬 소켓(Scoket)

**동일한 호스트 운영체제에서 실행되는 프로세스간 데이터를 교환하기 위한 데이터 통신 엔드 포인트**

- 네트워크 소켓 통신을 통해 데이터를 공유한다.
    - 데이터 교환을 위해 양쪽 PC에서 임의의 포트를 정하고 해당 포트 간의 대화를 통해 데이터를 주고 받는다.
- 양방향 통신이 가능하다

### 💬 메시지 큐

**메시지 큐는 파이프처럼 데이터의 흐름이 아니라 메모리 공간이다.**

- 다수의 프로세스간 메시지를 전달할 수 있다.

### 💬 메모리 맵

**공유 메모리처럼 메모리를 공유한다. 열린 파일을 메모리에 맵핑시켜서 공유하는 방식**

- 파일로 대용량 데이터를 공유할 때 사용

### 💬 RPC(Remote Procedure Call)

분산 네트워크 망에서 많이 사용되는 방식. 

**별도의 원격 제어를 위한 코딩 없이 다른 주소 공간에서 함수나 프로시저를 실행할 수 있게 하는 프로세스 간 통신 기술**

## 6️⃣ 입출력 관리

### 💬 폴링

CPU가 주기적으로 입출력 장치의 이벤트를 확인하는 방식, 입출력을 확인하는 시간동안 CPU 사용불가

### 💬 인터럽트

입출력 장치에서 CPU로 인터럽트 신호를 전송하여 필요할때마다 통신하는 방식

### 💬 DMA(Direct Memory Access)

CPU 대신 DMA Controller가 입출력 처리를 대신하는 방식

- 폴링과 인터럽트 단점을 해결하기 위한 방안
- 데이터 교환 때만 CPU 사용
- CPU에서 입출력 신호를 받고 DMA 호출

### 💬 채널(Channel)

CPU를 대신할 입출력 전용 프로세서인 채널을 사용하는 방식

- 채널은 CPU와 독립적으로 입출력 작업을 완료함
- CPU 대신 입출력 신호를 받고 작업 수행

## 7️⃣ POSIX 기초 (stdin, stdout, stderr, pipes)

**서로 다른 UNIX OS의 공통 API를 정리하여 이식성이 높은 유닉스 응용 프로그램을 개발하기 위한 목적으로 IEEE가 책정한 애플리케이션 인터페이스 규격**

---

**참고 자료**

[프로세스 관리 - 위키백과, 우리 모두의 백과사전](https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_%EA%B4%80%EB%A6%AC)

[[운영체제 기초]7. 프로세스 관리](https://iksflow.tistory.com/119)

[운영체제 4장 - 프로세스 관리(1) -](https://copycode.tistory.com/48)

[[운영체제] 쓰레드(Thread)란? | 쓰레드 프로세스 차이 | 멀티프로세스 멀티쓰레드 차이](https://code-lab1.tistory.com/43)

[스레드 (컴퓨팅) - 위키백과, 우리 모두의 백과사전](https://ko.wikipedia.org/wiki/%EC%8A%A4%EB%A0%88%EB%93%9C_(%EC%BB%B4%ED%93%A8%ED%8C%85))

[[운영체제]멀티 프로세스 vs 멀티 스레드](https://wookkingkim.tistory.com/entry/%EB%A9%80%ED%8B%B0-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-vs-%EB%A9%80%ED%8B%B0-%EC%8A%A4%EB%A0%88%EB%93%9C?category=977798)

[프로세스는 뭐고 스레드는 뭔가요?](https://youtu.be/iks_Xb9DtTM)

[메모리 관리 - 위키백과, 우리 모두의 백과사전](https://ko.wikipedia.org/wiki/%EB%A9%94%EB%AA%A8%EB%A6%AC_%EA%B4%80%EB%A6%AC)

[[운영체제 OS] 메모리 관리란? - 이유, 방법](https://technote-mezza.tistory.com/92)

[프로세스 간 통신 - 위키백과, 우리 모두의 백과사전](https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_%EA%B0%84_%ED%86%B5%EC%8B%A0)

[[OS] 프로세스 간 통신 방법(Inter Process Communication, IPC)](https://dar0m.tistory.com/233)

[1.컴퓨터 동작 원리 (운영체제)](https://89douner.tistory.com/149)

[POSIX - 위키백과, 우리 모두의 백과사전](https://ko.wikipedia.org/wiki/POSIX)
